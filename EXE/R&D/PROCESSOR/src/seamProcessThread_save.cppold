#include "seamProcessThread.h"

SeamProcessThread::SeamProcessThread() 
{
    thread = nullptr;
    finished = false;
    reader = new VideoHandler();
    writer = new VideoHandler();
}
SeamProcessThread::~SeamProcessThread() 
{
    if (thread != nullptr) {
        thread->join();
        delete thread;
    }
    if (reader != nullptr) {
        delete reader;
    }
    if (writer != nullptr) {
        delete writer;
    }
}

void SeamProcessThread::startThread(std::string filename, std::map<int, int> sceneCuts)
{
    nbFrames = -1;
    finished = false;
    this->sceneCuts = sceneCuts;
    this->fileIn = filename;
    Poco::Path path(filename);
    this->fileOut = filename.replace(filename.find(path.getBaseName()), path.getBaseName().length(), path.getBaseName() + "_out");
    Poco::Logger::get("SeamProcessThread").debug("Open video file : " + this->fileIn, __FILE__, __LINE__);
    Poco::Logger::get("SeamProcessThread").debug("Open out video file : " + fileOut, __FILE__, __LINE__);
    reader->openVideo(fileIn);

    thread = new Poco::Thread("SeamProcess");
    thread->setPriority(Poco::Thread::Priority::PRIO_HIGHEST);
    thread->start(*this);
}

void SeamProcessThread::run() 
{
    while (reader->getNbFrames() == -1) {Timer::crossUsleep(1000);}
    nbFrames = reader->getNbFrames();
    Poco::Logger::get("SeamProcessThread").debug(std::to_string(nbFrames) + " to transform !", __FILE__, __LINE__);
    writer->writeVideo(nbFrames, reader->getCodecParams(), reader->getPixelFormat(), fileOut);

    // -- stop only when all frames are written to output video file
    int currentIdx = 0;
    int* seamsLeft = nullptr;
    int* seamsRight = nullptr;
    float* sobelLeft = nullptr;
    float* sobelRight = nullptr;
    
    while (currentIdx < nbFrames - 1) {

        // -- look out for finished job
        if (reader->hasImageAtIndex(currentIdx)) {

            Image* in = reader->getImageAtIndex(currentIdx);
            reader->deleteImageAtIndex(currentIdx);

            if (seamsLeft == nullptr) {seamsLeft = new int[in->getHeight()*360];}
            if (seamsRight == nullptr) {seamsRight = new int[in->getHeight()*360];}
            if (sobelLeft == nullptr) {sobelLeft = new float[in->getHeight()*in->getWidth()/2];}
            if (sobelRight == nullptr) {sobelRight = new float[in->getHeight()*in->getWidth()/2];}

            SeamCarvingThread* seamThread = new SeamCarvingThread();
            seamThread->setSeams(seamsLeft, seamsRight);
            seamThread->setSobel(sobelLeft, sobelRight);
            if (sceneCuts.find(currentIdx) != sceneCuts.end()) {seamThread->startThread(currentIdx, in, true);}
            else {seamThread->startThread(currentIdx, in, false);}

            while (seamThread->getState() != SeamCarvingThread::FINISHED) {Timer::crossUsleep(1000);}

            delete in;
            Image* out = seamThread->getOut();
            seamThread->releaseDatas();
            writer->addImageAtIndex(currentIdx, out);

            Poco::Logger::get("SeamProcessThread").debug("Seam carving finished on index : " + std::to_string(currentIdx), __FILE__, __LINE__);
            currentIdx++;
            delete seamThread;
        }
        else {
            Timer::crossUsleep(1000);
        }
    }

    delete[] seamsLeft;
    delete[] seamsRight;

    while (!writer->isFinished()) {Timer::crossUsleep(10000);}
    Poco::Logger::get("SeamProcessThread").debug("All conversion terminated ", __FILE__, __LINE__);

    finished = true;
}